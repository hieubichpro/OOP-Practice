**Некоторые правило при использовании ООП**

1. Пишите имена классов с заглавной буквы.
2. Используйте ключевое слово struct для структур, используемых только для хранения данных. Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.
3. Устанавливайте спецификатор доступа private переменным-членам класса и спецификатор доступа public — методам класса (если у вас нет веских оснований делать иначе).
4. Предоставляйте функции доступа только в том случае, когда нужно, чтобы пользователь имел возможность получать или присваивать значения членам класса.
5. Геттеры должны использовать тип возврата по значению или по константной ссылке. Не используйте для геттеров тип возврата по неконстантной ссылке.
6. Используйте прямую инициализацию или uniform-инициализацию с объектами ваших классов.
7. Не используйте копирующую инициализацию с объектами ваших классов.
8. Про конструкторы: Если ваш класс имеет другие конструкторы, то неявно генерируемый конструктор создаваться не будет.
9. Создавайте хотя бы один конструктор в классе, даже если это пустой конструктор по умолчанию.
10. Используйте списки инициализации членов, вместо операций присваивания, для инициализации переменных-членов вашего класса.
11. Используйте uniform-инициализацию вместо прямой инициализации в C++11.
12. Не инициализируйте переменные-члены таким образом, чтобы они зависели от других переменных-членов, которые инициализируются первыми (другими словами, убедитесь, что все ваши переменные-члены правильно инициализируются, даже если порядок в списке инициализации отличается).
13. Инициализируйте переменные в списке инициализации в том порядке, в котором они объявлены в классе.
14. Идиома RAII (англ. «Resource Acquisition Is Initialization» = «Получение ресурсов есть инициализация»). Используйте идиому программирования RAII и не выделяйте объекты вашего класса динамически.
15. Делайте все ваши методы, которые не изменяют данные объекта класса, константными.
16. Не пишите определение статического члена класса в заголовочном файле
17. в C++11 добавили спецификатор constexpr, который сообщает компилятору, что текущая переменная является константой времени компиляции
18. Не используйте директиву #define для создания символьных констант. #define N 10. Хороший способ: Использовать переменные со спецификатором const.
19. Правило: Используйте перегрузку операторов через обычные функции, вместо дружественных, если для этого не требуется добавление дополнительных функций в класс.
20. Самое интересное здесь — тип возврата. С перегрузкой арифметических операторов мы вычисляли и возвращали результат по значению. Однако, если вы попытаетесь возвратить std::ostream по значению, то получите ошибку компилятора. Это случится из-за того, что std::ostream запрещает свое копирование.
21. Перегрузка операторов через методы класса не используется, если левый операнд не является классом (например, int), или это класс, который мы не можем изменить (например, std::ostream).
22. Поэтому:

Для операторов присваивания (=), индекса ([]), вызова функции (()) или выбора члена (->) используйте перегрузку через методы класса.

Для унарных операторов используйте перегрузку через методы класса.

Для перегрузки бинарных операторов, которые изменяют левый операнд (например, operator+=()) используйте перегрузку через методы класса, если это возможно.

Для перегрузки бинарных операторов, которые не изменяют левый операнд (например, operator+()) используйте перегрузку через обычные/дружественные функции. 23. Конструктор копирования — это особый тип конструктора, который используется для создания нового объекта через копирование существующего объекта. 24. Правило: Для предотвращения возникновения ошибок с неявными конвертациями делайте ваши конструкторы явными, используя ключевое слово explicit. 25. Обратите внимание, конструктор копирования и перегруженные операторы также могут быть удалены с помощью delete для предотвращения их использования.

26. Конструктор копирования — это особый тип конструктора, который используется для создания нового объекта через копирование существующего объекта. И, как в случае с конструктором по умолчанию, если вы не предоставите конструктор копирования для своих классов самостоятельно, то язык C++ создаст public-конструктор копирования автоматически. Поскольку компилятор мало знает о вашем классе, то по умолчанию созданный конструктор копирования будет использовать почленную инициализацию. Почленная инициализация означает, что каждый член объекта-копии инициализируется непосредственно из члена объекта-оригинала. Т.е. в примере, приведенном выше, dCopy.m*numerator будет иметь значение sixSeven.m_numerator (6), а dCopy.m_denominator будет равен sixSeven.m* denominator (7).

27. Мы можем предотвратить создание копий объектов наших классов, сделав конструктор копирования закрытым

28. Избегайте использования копирующей инициализации при работе с классами, вместо нее используйте uniform-инициализацию.

29. При поверхностном копировании указателя копируется только адрес указателя — никаких действий по содержимому адреса указателя не предпринимается
30. Глубокое копирование --- нам необходимо написать свой собственный конструктор копирования и перегрузку оператора присваивания. Иначе компилятор использует конструктор и перегрузка оператора присваивания по умолчанию (т.е поверхностное копирование)
31. Конструктор копирования и оператор присваивания, предоставляемые по умолчанию языком C++, выполняют поверхностное копирование, что отлично подходит для классов без динамически выделенных членов
    32.Классы с динамически выделенными членами должны иметь конструктор копирования и перегрузку оператора присваивания, которые выполняют глубокое копирование.
