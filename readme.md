**Некоторые правило при использовании ООП**

1. Пишите имена классов с заглавной буквы.
2. Используйте ключевое слово struct для структур, используемых только для хранения данных. Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.
3. Устанавливайте спецификатор доступа private переменным-членам класса и спецификатор доступа public — методам класса (если у вас нет веских оснований делать иначе).
4. Предоставляйте функции доступа только в том случае, когда нужно, чтобы пользователь имел возможность получать или присваивать значения членам класса.
5. Геттеры должны использовать тип возврата по значению или по константной ссылке. Не используйте для геттеров тип возврата по неконстантной ссылке.
6. Используйте прямую инициализацию или uniform-инициализацию с объектами ваших классов.
7. Не используйте копирующую инициализацию с объектами ваших классов.
8. Про конструкторы: Если ваш класс имеет другие конструкторы, то неявно генерируемый конструктор создаваться не будет.
9. Создавайте хотя бы один конструктор в классе, даже если это пустой конструктор по умолчанию.
10. Используйте списки инициализации членов, вместо операций присваивания, для инициализации переменных-членов вашего класса.
11. Используйте uniform-инициализацию вместо прямой инициализации в C++11.
12. Не инициализируйте переменные-члены таким образом, чтобы они зависели от других переменных-членов, которые инициализируются первыми (другими словами, убедитесь, что все ваши переменные-члены правильно инициализируются, даже если порядок в списке инициализации отличается).
13. Инициализируйте переменные в списке инициализации в том порядке, в котором они объявлены в классе.
14. Идиома RAII (англ. «Resource Acquisition Is Initialization» = «Получение ресурсов есть инициализация»). Используйте идиому программирования RAII и не выделяйте объекты вашего класса динамически.
15. Делайте все ваши методы, которые не изменяют данные объекта класса, константными.
16. Не пишите определение статического члена класса в заголовочном файле
17. в C++11 добавили спецификатор constexpr, который сообщает компилятору, что текущая переменная является константой времени компиляции
18. Не используйте директиву #define для создания символьных констант. #define N 10. Хороший способ: Использовать переменные со спецификатором const.
19. Правило: Используйте перегрузку операторов через обычные функции, вместо дружественных, если для этого не требуется добавление дополнительных функций в класс.
20. Самое интересное здесь — тип возврата. С перегрузкой арифметических операторов мы вычисляли и возвращали результат по значению. Однако, если вы попытаетесь возвратить std::ostream по значению, то получите ошибку компилятора. Это случится из-за того, что std::ostream запрещает свое копирование.
21. Перегрузка операторов через методы класса не используется, если левый операнд не является классом (например, int), или это класс, который мы не можем изменить (например, std::ostream).
22. Поэтому:

Для операторов присваивания (=), индекса ([]), вызова функции (()) или выбора члена (->) используйте перегрузку через методы класса.

Для унарных операторов используйте перегрузку через методы класса.

Для перегрузки бинарных операторов, которые изменяют левый операнд (например, operator+=()) используйте перегрузку через методы класса, если это возможно.

Для перегрузки бинарных операторов, которые не изменяют левый операнд (например, operator+()) используйте перегрузку через обычные/дружественные функции. 23. Конструктор копирования — это особый тип конструктора, который используется для создания нового объекта через копирование существующего объекта. 24. Правило: Для предотвращения возникновения ошибок с неявными конвертациями делайте ваши конструкторы явными, используя ключевое слово explicit. 25. Обратите внимание, конструктор копирования и перегруженные операторы также могут быть удалены с помощью delete для предотвращения их использования.

26. Конструктор копирования — это особый тип конструктора, который используется для создания нового объекта через копирование существующего объекта. И, как в случае с конструктором по умолчанию, если вы не предоставите конструктор копирования для своих классов самостоятельно, то язык C++ создаст public-конструктор копирования автоматически. Поскольку компилятор мало знает о вашем классе, то по умолчанию созданный конструктор копирования будет использовать почленную инициализацию. Почленная инициализация означает, что каждый член объекта-копии инициализируется непосредственно из члена объекта-оригинала. Т.е. в примере, приведенном выше, dCopy.m*numerator будет иметь значение sixSeven.m_numerator (6), а dCopy.m_denominator будет равен sixSeven.m* denominator (7).

27. Мы можем предотвратить создание копий объектов наших классов, сделав конструктор копирования закрытым

28. Избегайте использования копирующей инициализации при работе с классами, вместо нее используйте uniform-инициализацию.

29. При поверхностном копировании указателя копируется только адрес указателя — никаких действий по содержимому адреса указателя не предпринимается
30. Глубокое копирование --- нам необходимо написать свой собственный конструктор копирования и перегрузку оператора присваивания. Иначе компилятор использует конструктор и перегрузка оператора присваивания по умолчанию (т.е поверхностное копирование)
31. Конструктор копирования и оператор присваивания, предоставляемые по умолчанию языком C++, выполняют поверхностное копирование, что отлично подходит для классов без динамически выделенных членов.

32.Классы с динамически выделенными членами должны иметь конструктор копирования и перегрузку оператора присваивания, которые выполняют глубокое копирование.

33. Реализовывайте самые простые отношения, которые соответствуют потребностям вашей программы, а не то, что, как вам кажется, будет лучше. (Композиция обьекта состоит из композиции и агрегации).

34. Зависимость возникает, когда один объект обращается к функционалу другого объекта для выполнения определенного задания. Зависимость всегда является однонаправленной.

35. Контейнеры значения — это композиции, которые хранят копии объектов (и, следовательно, ответственные за создание/уничтожение этих копий).
36. Контейнеры ссылки — это агрегации, которые хранят указатели или ссылки на другие объекты (и, следовательно, не ответственные за создание/уничтожение этих объектов).

37. Доступ к членам public открыт для всех. Доступ к членам private открыт только для других членов этого же класса. Обратите внимание, это означает, что дочерние классы не могут напрямую обращаться к закрытым членам родительского класса! Дочерним классам нужно использовать геттеры и сеттеры для доступа к этим членам.

38. Используйте открытое наследование, если у вас нет веских причин делать иначе.

39. Обратите внимание, когда мы переопределяем родительский метод в дочернем классе, то дочерний метод не наследует спецификатор доступа родительского метода с тем же именем. Используется тот спецификатор доступа, который указан в дочернем классе. Таким образом, метод, определенный как private в родительском классе, может быть переопределен как public в дочернем классе, или наоборот!
40. Использование оператора разрешения области видимости является обязательным условием при изменении методов родительского класса.
41. Используйте множественное наследование только в крайних случаях, когда задачу нельзя решить одиночным наследованием, либо другим альтернативным способом (без изобретения «велосипеда»).

42. Дочерние классы могут изменять методы родительского класса, добавлять свой функционал, изменять спецификатор доступа наследуемых членов или даже скрывать методы родительского класса. Всё это выполняется в теле дочернего класса.

43. Виртуальная функция в языке С++ — это особый тип функции, которая, при её вызове, выполняет «наиболее» дочерний метод, который существует между родительским и дочерними классами. Это свойство еще известно, как полиморфизм.

44. Сигнатура виртуального метода дочернего класса должна полностью соответствовать сигнатуре виртуального метода родительского класса. Если у дочернего метода будет другой тип параметров, нежели у родительского, то вызываться этот метод не будет.

45. Если функция отмечена как виртуальная, то все соответствующие переопределения тоже считаются виртуальными, даже если возле них явно не указано ключевое слова virtual. Однако, наличие ключевого слова virtual возле методов дочерних классов послужит полезным напоминанием о том, что эти методы являются виртуальными, а не обычными. Следовательно, полезно указывать ключевое слово virtual возле переопределений в дочерних классах, даже если это не является строго необходимым.

46. Никогда не вызывайте виртуальные функции в теле конструкторов или деструкторов.
47. Используйте модификатор override для каждого из своих переопределений.
48. Могут быть случаи, когда вы не хотите, чтобы кто-то мог переопределить виртуальную функцию или наследовать определенный класс. Модификатор final используется именно для этого.
49. При работе с наследованием ваши деструкторы должны быть виртуальными.
50. Для сохранения простоты в вашем коде, не рекомендуется использовать виртуальное присваивание.
51. Любой класс, который использует виртуальные функции, имеет свой \*\_\_vptr, и размер каждого объекта этого класса увеличивается на размер этого указателя. Виртуальные функции мощные, но цена этому — производительность.
52. C++ позволяет создавать особый вид виртуальных функций, так называемых чистых виртуальных функций (или «абстрактных функций»), которые вообще не имеют определения! Переопределяют их дочерние классы.

53. Чистая виртуальная функция полезна, когда у нас есть функция, которую мы хотим поместить в родительский класс, но реализацию оставить дочерним классам. Чистая виртуальная функция абстрактного родительского класса вынуждает дочерние классы переопределить эту функцию, иначе объекты этих классов создавать будет невозможно.

54. Интерфейс — это класс, который не имеет переменных-членов и все методы которого являются чистыми виртуальными функциями!

55. Не забудьте о подключении виртуальных деструкторов в ваши интерфейсные классы, чтобы при удалении указателя на интерфейс вызывался деструктор соответствующего (дочернего) класса.

56. Виртуальный базовый класс — это класс, объект которого является общим для использования всеми дочерними классами

57. В примере, приведенном выше, parent получает копию части Parent объекта child, а часть Child объекта child «обрезается». Это называется обрезкой объектов (или просто «обрезкой»).

58. Стандартная библиотека C++ предоставляет класс std::reference_wrapper. По сути, std::reference_wrapper — это класс, который работает как ссылка, но позволяет выполнять операции присваивания и копирования и совместим с std::vector.

59. Всегда делайте проверку результата динамического приведения на нулевой указатель.

60. используйте оператор dynamic_cast при понижающем приведении, а во всех остальных случаях используйте оператор static_cast.
